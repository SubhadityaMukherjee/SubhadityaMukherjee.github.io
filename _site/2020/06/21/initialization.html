<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML">

</script>
    <!-- To automatically render math in text elements, include the auto-render extension: --> 

<!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Initialization | Deconstructing Deep learning</title>
<meta name="generator" content="Jekyll v3.8.7" />
<meta property="og:title" content="Initialization" />
<meta name="author" content="Subhaditya Mukherjee" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="We explore the different initialization techniques that we have and look at papers to see which does better." />
<meta property="og:description" content="We explore the different initialization techniques that we have and look at papers to see which does better." />
<link rel="canonical" href="http://localhost:4000/2020/06/21/initialization.html" />
<meta property="og:url" content="http://localhost:4000/2020/06/21/initialization.html" />
<meta property="og:site_name" content="Deconstructing Deep learning" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-06-21T13:58:32+04:00" />
<script type="application/ld+json">
{"@type":"BlogPosting","url":"http://localhost:4000/2020/06/21/initialization.html","headline":"Initialization","dateModified":"2020-06-21T13:58:32+04:00","datePublished":"2020-06-21T13:58:32+04:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2020/06/21/initialization.html"},"author":{"@type":"Person","name":"Subhaditya Mukherjee"},"description":"We explore the different initialization techniques that we have and look at papers to see which does better.","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/css/style.css?v=">
    <!--[if lt IE 9]>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h2><a href="http://localhost:4000/">Home page</a></h2>


        

        <p>Making a Deep Learning library from scratch and explaining it the whole way + Related deviations</p>

<p>
- <a href = "mailto: msubhaditya@gmail.com">Drop me an email</a><br>
- RSS feed link : <a href ="https://subhadityamukherjee.github.io/feed.xml">Click</a><br>
- Source? Refer to the repository <a href="https://github.com/SubhadityaMukherjee/DataLoader.jl">Link</a><br>
- The posts are in the order of newer -> older <br>
- Format : 
Date | Title<br>
&emsp;TL; DR<br>
- &#9998;: Post, &#9883; : Deviation, &#128214;: Book notes
</p>

        

        
      </header>
      
      <section>
            <!-- Html Elements for Search -->
<div id="search-container">
Search for something in the blog <input type="text" id="search-input" placeholder="search...">
<ul id="results-container"></ul>
</div>

<!-- Script pointing to search-script.js -->
<script src="js/search-script.js" type="text/javascript"></script>

<!-- Configuration -->
<script>
SimpleJekyllSearch({
  searchInput: document.getElementById('search-input'),
  resultsContainer: document.getElementById('results-container'),
  json: '/search.json'
})
</script>

      <a href = "/deconstructingdl.html">Go to index</a><br><br>


<small>21 June 2020</small>
<h1>Initialization</h1>

<span class="reading-time" title="Estimated read time">
  
  
    <h3>Reading time : ~4 mins</h3>
  
</span>


<p class="view">by Subhaditya Mukherjee</p>


<p>We explore the different initialization techniques that we have and look at papers to see which does better.</p>

<p>Here goes!</p>

<ul>
  <li>Zero Initialization: set all weights to 0
Please dont. I mean its the worst idea. But anyway.</li>
</ul>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">W</span> <span class="o">=</span> <span class="n">zeros</span><span class="x">(</span><span class="mi">2</span><span class="x">,</span><span class="mi">100</span><span class="x">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">zeros</span><span class="x">(</span><span class="mi">2</span><span class="x">)</span>
</code></pre></div></div>

<ul>
  <li>Normal Initialization: set all weights to random small numbers</li>
</ul>

<p>This is what we did as a test. It does better than init 0 but still. Not a great idea.</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">W</span> <span class="o">=</span> <span class="n">rand</span><span class="x">(</span><span class="mi">2</span><span class="x">,</span><span class="mi">100</span><span class="x">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">rand</span><span class="x">(</span><span class="mi">2</span><span class="x">)</span>
</code></pre></div></div>

<ul>
  <li>Lecun Initialization: normalize variance</li>
</ul>

<p>LeCun, Y. A., Bottou, L., Orr, G. B., &amp; Müller, K. R. (2012). Efficient backprop. In Neural networks: Tricks of the trade (pp. 9-48). Springer, Berlin, Heidelberg.</p>

<p>Since variance grows with number of inputs. This makes it constant xD
It draws samples from a truncated normal distribution centered on 0 with stddev &lt;- sqrt(1 / fan_in) where fan_in is the number of input units in the weight tensor.</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="n">Distributions</span>
<span class="n">lecun_normal</span><span class="x">(</span><span class="n">fan_in</span><span class="x">)</span> <span class="o">=</span> <span class="k">return</span> <span class="n">Distributions</span><span class="o">.</span><span class="n">Normal</span><span class="x">(</span><span class="mi">0</span><span class="x">,</span> <span class="n">sqrt</span><span class="x">(</span><span class="mi">1</span><span class="o">/</span><span class="n">fan_in</span><span class="x">))</span>
<span class="n">W</span> <span class="o">=</span> <span class="n">rand</span><span class="x">(</span><span class="n">lecun_normal</span><span class="x">(</span><span class="mi">2</span><span class="x">),</span> <span class="mi">2</span><span class="x">,</span> <span class="mi">100</span><span class="x">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">rand</span><span class="x">(</span><span class="n">lecun_normal</span><span class="x">(</span><span class="mi">2</span><span class="x">),</span> <span class="mi">2</span><span class="x">)</span>
</code></pre></div></div>

<ul>
  <li>Xavier Intialization (glorot init)
X. Glorot and Y. Bengio, “Understanding the difficulty of training deep feedforward neural networks,” in International conference on artificial intelligence and statistics, 2010, pp. 249–256.</li>
</ul>

<p>This works better with Sigmoid activations.</p>

<p>There are two of them. Xavier normal and Xavier uniform.
First Xavier Normal - It draws samples from a truncated normal distribution centered on 0 with stddev = sqrt(2 / (fan_in + fan_out)) where fan_in is the number of input units in the weight tensor and fan_out is the number of output units in the weight tensor.</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">xavier_normal</span><span class="x">(</span><span class="n">fan_in</span><span class="x">,</span><span class="n">fan_out</span><span class="x">)</span> <span class="o">=</span> <span class="k">return</span> <span class="n">Distributions</span><span class="o">.</span><span class="n">Normal</span><span class="x">(</span><span class="mi">0</span><span class="x">,</span> <span class="n">sqrt</span><span class="x">(</span><span class="mi">2</span><span class="o">/</span><span class="x">(</span><span class="n">fan_in</span><span class="o">+</span><span class="n">fan_out</span><span class="x">)))</span>

<span class="n">W</span> <span class="o">=</span> <span class="n">rand</span><span class="x">(</span><span class="n">xavier_normal</span><span class="x">(</span><span class="mi">2</span><span class="x">,</span><span class="mi">100</span><span class="x">),</span> <span class="mi">2</span><span class="x">,</span> <span class="mi">100</span><span class="x">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">rand</span><span class="x">(</span><span class="n">xavier_normal</span><span class="x">(</span><span class="mi">2</span><span class="x">,</span><span class="mi">2</span><span class="x">),</span> <span class="mi">2</span><span class="x">)</span>
</code></pre></div></div>

<p>Now Xavier Uniform - It draws samples from a uniform distribution within -limit, limit where limit is sqrt(6 / (fan_in + fan_out)) where fan_in is the number of input units in the weight tensor and fan_out is the number of output units in the weight tensor.</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span><span class="nf"> xavier_uniform</span><span class="x">(</span><span class="n">fan_in</span><span class="x">,</span><span class="n">fan_out</span><span class="x">)</span>
    <span class="n">limit</span> <span class="o">=</span> <span class="n">sqrt</span><span class="x">(</span><span class="mi">6</span><span class="o">/</span><span class="x">(</span><span class="n">fan_in</span><span class="o">+</span><span class="n">fan_out</span><span class="x">))</span>
    <span class="k">return</span> <span class="n">Distributions</span><span class="o">.</span><span class="n">Uniform</span><span class="x">(</span><span class="o">-</span><span class="n">limit</span><span class="x">,</span> <span class="n">limit</span><span class="x">)</span>
<span class="k">end</span>

<span class="n">W</span> <span class="o">=</span> <span class="n">rand</span><span class="x">(</span><span class="n">xavier_uniform</span><span class="x">(</span><span class="mi">2</span><span class="x">,</span><span class="mi">100</span><span class="x">),</span> <span class="mi">2</span><span class="x">,</span> <span class="mi">100</span><span class="x">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">rand</span><span class="x">(</span><span class="n">xavier_uniform</span><span class="x">(</span><span class="mi">2</span><span class="x">,</span><span class="mi">2</span><span class="x">),</span> <span class="mi">2</span><span class="x">)</span>
</code></pre></div></div>

<ul>
  <li>Kaiming Initialization (he init)</li>
</ul>

<p>K. He, X. Zhang, S. Ren, and J. Sun, “Delving Deep into Rectifiers: Surpassing Human-Level Performance on ImageNet Classification,” arXiv:1502.01852 [cs], Feb. 2015.</p>

<p>This works better with ReLU/Leaky ReLU activations. This is mostly used everywhere because we use ReLU more than Sigmoid now.
Wow. This is just different from Xavier in the fact that there is no fan out :/ And here I thought it was some complicated thing.</p>

<p>He Normal - It draws samples from a truncated normal distribution centered on 0 with stddev = sqrt(2 / fan_in) where fan_in is the number of input units in the weight tensor.</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">he_normal</span><span class="x">(</span><span class="n">fan_in</span><span class="x">)</span> <span class="o">=</span> <span class="k">return</span> <span class="n">Distributions</span><span class="o">.</span><span class="n">Normal</span><span class="x">(</span><span class="mi">0</span><span class="x">,</span> <span class="n">sqrt</span><span class="x">(</span><span class="mi">2</span><span class="o">/</span><span class="x">(</span><span class="n">fan_in</span><span class="x">)))</span>

<span class="n">W</span> <span class="o">=</span> <span class="n">rand</span><span class="x">(</span><span class="n">he_normal</span><span class="x">(</span><span class="mi">2</span><span class="x">),</span> <span class="mi">2</span><span class="x">,</span> <span class="mi">100</span><span class="x">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">rand</span><span class="x">(</span><span class="n">he_normal</span><span class="x">(</span><span class="mi">2</span><span class="x">),</span> <span class="mi">2</span><span class="x">)</span>
</code></pre></div></div>

<p>He uniform - It draws samples from a uniform distribution within -limit, limit where limit is sqrt(6 / fan_in) where fan_in is the number of input units in the weight tensor.</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#export</span>
<span class="k">function</span><span class="nf"> he_uniform</span><span class="x">(</span><span class="n">fan_in</span><span class="x">)</span>
    <span class="n">limit</span> <span class="o">=</span> <span class="n">sqrt</span><span class="x">(</span><span class="mi">6</span><span class="o">/</span><span class="x">(</span><span class="n">fan_in</span><span class="x">))</span>
    <span class="k">return</span> <span class="n">Distributions</span><span class="o">.</span><span class="n">Uniform</span><span class="x">(</span><span class="o">-</span><span class="n">limit</span><span class="x">,</span> <span class="n">limit</span><span class="x">)</span>
<span class="k">end</span>

<span class="n">W</span> <span class="o">=</span> <span class="n">rand</span><span class="x">(</span><span class="n">he_uniform</span><span class="x">(</span><span class="mi">2</span><span class="x">),</span> <span class="mi">2</span><span class="x">,</span> <span class="mi">100</span><span class="x">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">rand</span><span class="x">(</span><span class="n">he_uniform</span><span class="x">(</span><span class="mi">2</span><span class="x">),</span> <span class="mi">2</span><span class="x">)</span>
</code></pre></div></div>

<ul>
  <li>LSUV
Mishkin, D., &amp; Matas, J. (2015). All you need is a good init. arXiv preprint arXiv:1511.06422.</li>
</ul>

<p>We cannot implement this yet because it requires us to hook into the model while it is training ):
But all it does is when the mean of the current output is &gt; 1e^-3 then we subtract the mean from the bias.
If the current outputs standard deviation -1 is &gt; 1e^-3 then we divide the weight by the standard deviation.</p>





  <small>tags: <em>inititialize</em> - <em>xavier</em> - <em>he</em> - <em>glorot</em> - <em>kaiming</em> - <em>normal</em> - <em>random</em> - <em>uniform</em> - <em>zeros</em> - <em>lsuv</em></small>



      </section>
      <footer>
        
      </footer>
    </div>
    <script src="/assets/js/scale.fix.js"></script>
    
  </body>
</html>