<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link type = text/css rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">

    <!-- The loading of KaTeX is deferred to speed up page rendering -->
    <script type = text/javascript defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>

    <!-- To automatically render math in text elements, include the auto-render extension: -->
    <script type = text/javascript  defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
        onload="renderMathInElement(document.body);"></script>


<!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Batching | Deconstructing Deep learning</title>
<meta name="generator" content="Jekyll v3.8.7" />
<meta property="og:title" content="Batching" />
<meta name="author" content="Subhaditya Mukherjee" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Implementing batching for large data. Onehot and data batching. This is a precursor to everything from optimizers to the actual training loop itself." />
<meta property="og:description" content="Implementing batching for large data. Onehot and data batching. This is a precursor to everything from optimizers to the actual training loop itself." />
<link rel="canonical" href="http://localhost:4000/2020/06/23/batching.html" />
<meta property="og:url" content="http://localhost:4000/2020/06/23/batching.html" />
<meta property="og:site_name" content="Deconstructing Deep learning" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-06-23T18:48:06+04:00" />
<script type="application/ld+json">
{"@type":"BlogPosting","url":"http://localhost:4000/2020/06/23/batching.html","headline":"Batching","dateModified":"2020-06-23T18:48:06+04:00","datePublished":"2020-06-23T18:48:06+04:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2020/06/23/batching.html"},"author":{"@type":"Person","name":"Subhaditya Mukherjee"},"description":"Implementing batching for large data. Onehot and data batching. This is a precursor to everything from optimizers to the actual training loop itself.","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/css/style.css?v=d75938eb263a78ce6542fad6f5225ab78d247a88">
    <!--[if lt IE 9]>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1><a href="https://subhadityamukherjee.github.io/deconstructingdl.html">Home</a></h1>
	<h1><a href="https://subhadityamukherjee.github.io/">About me</a></h1>
	<h1><a href = "mailto: msubhaditya@gmail.com">Drop me an email</a></h1>

        <p>Making a Deep Learning library from scratch in Julia and documenting it the whole way!</p>

        
        <p class="view"><a href="https://github.com/SubhadityaMukherjee/DataLoader.jl">View the Project on GitHub <small>github.com/SubhadityaMukherjee/DataLoader.jl</small></a></p>
        

        

        
      </header>
      <section>
      <!-- Html Elements for Search -->
<div id="search-container">
Search for something in the blog <input type="text" id="search-input" placeholder="search...">
<ul id="results-container"></ul>
</div>

<!-- Script pointing to search-script.js -->
<script src="js/search-script.js" type="text/javascript"></script>

<!-- Configuration -->
<script>
SimpleJekyllSearch({
  searchInput: document.getElementById('search-input'),
  resultsContainer: document.getElementById('results-container'),
  json: '/search.json'
})
</script>

      <small>23 June 2020</small>
<h1>Batching</h1>

<p class="view">by Subhaditya Mukherjee</p>

<p>Implementing batching for large data. Onehot and data batching. This is a precursor to everything from optimizers to the actual training loop itself.</p>

<p>First let us look at one hot encoding. Simply put it is encoding the labels as numbers. Should not be particularly challenging.
What do we intend to achieve? Well lets say we have “cat” “dog”. All we need to do is label these as 0,1 and have a way to convert them back to “cat” “dog”.</p>

<p>We first identify the unique elements. Then we pop them into a dictionary of numbers from 1 to number of unique.</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">labels</span> <span class="o">=</span> <span class="n">unique</span><span class="x">(</span><span class="n">y_enc</span><span class="x">)</span>
<span class="n">encodedlabels</span> <span class="o">=</span> <span class="kt">Dict</span><span class="x">(</span><span class="n">labels</span> <span class="o">.=&gt;</span> <span class="n">collect</span><span class="x">(</span><span class="mi">1</span><span class="o">:</span><span class="n">length</span><span class="x">(</span><span class="n">labels</span><span class="x">)))</span>
</code></pre></div></div>

<p>Now that we have that out of the way, we have to map the entire list from before with these values. I thought it would be as simple as using a map but apparently not.</p>

<p>So it finally worked! I had to use a global function and a fancy replace function to get it to work.</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span><span class="nf"> onecold</span><span class="x">(</span><span class="n">y_enc</span><span class="x">)</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="n">unique</span><span class="x">(</span><span class="n">y_enc</span><span class="x">)</span>
    <span class="n">encodedlabels</span> <span class="o">=</span> <span class="kt">Dict</span><span class="x">(</span><span class="n">labels</span> <span class="o">.=&gt;</span> <span class="n">collect</span><span class="x">(</span><span class="mi">1</span><span class="o">:</span><span class="n">length</span><span class="x">(</span><span class="n">labels</span><span class="x">)))</span>
    <span class="kd">global</span> <span class="n">ytrain</span>
    <span class="k">for</span> <span class="n">a</span> <span class="k">in</span> <span class="n">keys</span><span class="x">(</span><span class="n">encodedlabels</span><span class="x">)</span>
        <span class="n">ytrain</span> <span class="o">=</span> <span class="n">replace</span><span class="x">(</span><span class="n">ytrain</span><span class="x">,</span> <span class="n">a</span><span class="o">=&gt;</span><span class="n">encodedlabels</span><span class="x">[</span><span class="n">a</span><span class="x">])</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Oh and I also changed my IDE. I am using <a href="https://junolab.org/">Juno</a> and <a href="https://atom.io/">Atom</a>.</p>

<p>Okay now for images. The hardest part and something I am <em>not</em> looking forward to.
Hold on. Now that I think about it. The index to the image array which we made before was literally just this.</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">X</span><span class="x">[</span><span class="o">:</span><span class="x">,</span> <span class="o">:</span><span class="x">,</span> <span class="o">:</span><span class="x">,</span> <span class="n">idx</span><span class="x">]</span>
</code></pre></div></div>

<p>Since idx is the index, cant we just do idx:final_idx?
OH MY! It works!!</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">X</span><span class="x">[</span><span class="o">:</span><span class="x">,</span> <span class="o">:</span><span class="x">,</span> <span class="o">:</span><span class="x">,</span> <span class="mi">1</span><span class="o">:</span><span class="n">batch_size</span><span class="x">]</span>
</code></pre></div></div>

<p>This would give me a batch. But the question is. How do I make it into a generator :/ I need to it give me the “next” batch when I call a function. So I do not have to store an index value. Because it is dumb and boring.</p>

<p>So I decided to go by a generator approach. What this means is that we have a function (called a co-routine) which basically stores a state. For example if we want to increment a number everytime we call the function till a point, we can just call it directly. As an example.</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span><span class="nf"> testGen</span><span class="x">(</span><span class="n">c</span><span class="o">::</span><span class="kt">Channel</span><span class="x">)</span>
    <span class="k">for</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="o">:</span><span class="mi">4</span>
        <span class="n">put!</span><span class="x">(</span><span class="n">c</span><span class="x">,</span><span class="n">n</span><span class="x">)</span>
    <span class="k">end</span>
    <span class="n">put!</span><span class="x">(</span><span class="n">c</span><span class="x">,</span><span class="s">"stop"</span><span class="x">)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>This is a function. If we want to increment it, all we do is call.</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">test_yi</span> <span class="o">=</span> <span class="n">Cha</span>
<span class="n">take!</span><span class="x">(</span><span class="n">test_yi</span><span class="x">)</span>
</code></pre></div></div>

<p>Now for the actual batching. Okay so there is a problem. The batch cannot return the whole array :/ I dont know why but maybe I just dont know enough Julia.</p>

<p>How about returning the indexes instead though. I think that should be enough. Lets see.
Okay that took a bit of modification.</p>

<p>We make the function to yield the next index taking into account batch size.</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">function</span><span class="nf"> datagen</span><span class="x">(</span><span class="n">c</span><span class="o">::</span><span class="kt">Channel</span><span class="x">)</span>
    <span class="kd">global</span> <span class="n">rep_len</span>
    <span class="k">for</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="o">:</span><span class="n">bs</span><span class="o">:</span><span class="n">rep_len</span>
        <span class="n">put!</span><span class="x">(</span><span class="n">c</span><span class="x">,</span><span class="n">n</span><span class="x">);</span>
    <span class="k">end</span>
    <span class="n">put!</span><span class="x">(</span><span class="n">c</span><span class="x">,</span><span class="s">"stop"</span><span class="x">);</span>
<span class="k">end</span>

<span class="n">bs</span> <span class="o">=</span> <span class="mi">64</span>
<span class="n">rep_len</span> <span class="o">=</span> <span class="n">length</span><span class="x">(</span><span class="n">ytest</span><span class="x">)</span>
<span class="n">bunchData</span> <span class="o">=</span> <span class="kt">Channel</span><span class="x">(</span><span class="n">datagen</span><span class="x">);</span>
</code></pre></div></div>

<p>Now we use this to define the iteration over the batches. We index into the images as well as the labels with the yield of the generator function. As a test, let us check the size of the outputs to see if the batch size is correct.
The try catch is to identify the end of the batch.</p>

<div class="language-julia highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">bs</span> <span class="o">=</span> <span class="mi">64</span>
<span class="n">rep_len</span> <span class="o">=</span> <span class="n">length</span><span class="x">(</span><span class="n">ytest</span><span class="x">)</span>
<span class="n">bunchData</span> <span class="o">=</span> <span class="kt">Channel</span><span class="x">(</span><span class="n">datagen</span><span class="x">);</span>
<span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">collect</span><span class="x">(</span><span class="mi">1</span><span class="o">:</span><span class="n">round</span><span class="x">(</span><span class="n">rep_len</span><span class="o">/</span><span class="n">bs</span><span class="x">)</span><span class="o">+</span><span class="mi">1</span><span class="x">)</span>
    <span class="n">current_index</span> <span class="o">=</span> <span class="n">take!</span><span class="x">(</span><span class="n">bunchData</span><span class="x">)</span>
    <span class="k">try</span>
        <span class="n">x_batch</span><span class="x">,</span><span class="n">y_batch</span> <span class="o">=</span> <span class="n">Xtest</span><span class="x">[</span><span class="o">:</span><span class="x">,</span> <span class="o">:</span><span class="x">,</span> <span class="o">:</span><span class="x">,</span> <span class="n">current_index</span><span class="o">:</span><span class="n">current_index</span><span class="o">+</span><span class="n">bs</span><span class="o">-</span><span class="mi">1</span><span class="x">],</span><span class="n">ytest</span><span class="x">[</span><span class="n">current_index</span><span class="o">:</span><span class="n">current_index</span><span class="o">+</span><span class="n">bs</span><span class="o">-</span><span class="mi">1</span><span class="x">]</span>
        <span class="nd">@info</span> <span class="n">size</span><span class="x">(</span><span class="n">x_batch</span><span class="x">),</span><span class="n">size</span><span class="x">(</span><span class="n">y_batch</span><span class="x">)</span>
    <span class="k">catch</span> <span class="n">e</span>
        <span class="n">x_batch</span><span class="x">,</span><span class="n">y_batch</span> <span class="o">=</span> <span class="n">Xtest</span><span class="x">[</span><span class="o">:</span><span class="x">,</span> <span class="o">:</span><span class="x">,</span> <span class="o">:</span><span class="x">,</span> <span class="n">rep_len</span><span class="o">-</span><span class="n">bs</span><span class="o">:</span><span class="n">rep_len</span><span class="x">],</span><span class="n">ytest</span><span class="x">[</span><span class="n">rep_len</span><span class="o">-</span><span class="n">bs</span><span class="o">:</span><span class="n">rep_len</span><span class="x">]</span>
        <span class="nd">@info</span> <span class="n">size</span><span class="x">(</span><span class="n">x_batch</span><span class="x">),</span><span class="n">size</span><span class="x">(</span><span class="n">y_batch</span><span class="x">)</span>
    <span class="k">end</span>
<span class="k">end</span>

</code></pre></div></div>

<p>And now we have a dataloader which takes into account batch size. Guess we can go ahead and implement optimizers and the rest of the loop now :)</p>



  <small>tags: <em>batch</em> - <em>one</em> - <em>hot</em> - <em>loop</em> - <em>dictionary</em> - <em>ide</em> - <em>editor</em> - <em>iteration</em> - <em>loader</em> - <em>data</em> - <em>dataloader</em> - <em>encoding</em> - <em>cold</em></small>



      </section>
      <footer>
       
        <p>This project is maintained by <a href="https://github.com/SubhadityaMukherjee">SubhadityaMukherjee</a></p>
   
      </footer>
    </div>
    <script src="/assets/js/scale.fix.js"></script>
    
  </body>
</html>
